{
    "ja3_hash": "8ckwj4b0efdefa24a7f2b8eb6985bf37",
    "ja4_hash": "t13i2012h1_1e948f1242c7_d9433a03ec64",
    "ja4h_hash": "ge11cn060000_4e59edc1297a_4da5efaf0cbd",
    "ja4l_hash": "5191_42_45014",
    "get_header_signature": "1a93b037806d72961f17aa649841b9cbb70f1281428e3235128b9e24cde69fe5",
    "post_header_signature": "953eea58fdd34dfe4f0760f131a78cab9abdcab2800a5c5569eb418e01d97c7e",
    "user_agent": "Mozilla/5.0 (iPhone; CPU iPhone OS 17_3_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.3.1 Mobile/15E148 Safari/604.1",
    "accept": "*/*",
    "accept_encoding": "gzip, deflate, br",
    "accept_language": "en-US,en;q=0.9",
    "connection": "keep-alive",
    "content_length": "244",
    "host": "api.devtest.com",
    "source_ipv4": "200.124.2.4"
}



adjust the variation_threshold to 0.230 and test the code with a scenario where the variables source_ipv4 and ja3_hash and user-agent change in every request, considering test 6 random requests where the last only a ja4h also changed.


The deviations for source_ipv4, ja3_hash, user-agent, and ja4_hash are significant (between 0.5 and 0.75).
The variation_threshold is 0.245, ensuring the volatility penalty applies if the score's relative change from the previous score surpasses this threshold.
The volatility_penalty remains at 0.4, enhancing the score by 40% if the threshold condition is met.










import random

# Define weights for each scoring variable
weights = {
    "ja3_hash": 0.45921,
    "ja4_hash": 0.34823,
    "ja4h_hash": 0.6739,
    "ja4l_hash": 0.1028,
    "get_header_signature": 0.24534,
    "post_header_signature": 0.34512,
    "content_length": 0.35828,  # Restored weight for significant changes
    "user_agent": 0.29481,
    "source_ipv4": 0.14992
}

# Define a variation threshold for applying the volatility penalty
variation_threshold_adjusted = 0.230
volatility_penalty = 0.4

# Function to calculate score with adjusted logic for minor content-length changes
def calculate_score(deviations, weights, last_score, variation_threshold_adjusted, volatility_penalty):
    # Calculate the score considering deviations and weights
    score = sum(deviations[var] * weights[var] for var in deviations)
    
    # Apply the volatility penalty if necessary
    if last_score > 0 and abs(score - last_score) / last_score > variation_threshold_adjusted:
        score *= (1 + volatility_penalty)
    
    return score

# Simulate 17 random requests
last_score = 0.1  # Initialize with a small non-zero value
scores = []

for i in range(17):
    # Generate deviations for the scenario
    deviations = {
        "source_ipv4": random.uniform(0.5, 0.75) if i < 5 or i == 16 else 0.01,  # Minimal impact unless specified
        "user_agent": random.uniform(0.5, 0.75) if i < 5 else 0.01,
        "post_header_signature": random.uniform(0.5, 0.75) if i < 5 else 0.01,
        "content_length": random.uniform(0.01, 0.03),  # Minor changes for all requests
        "ja4h_hash": random.uniform(0.5, 0.75) if i == 16 else 0.01  # Significant change for one request
    }

    # Calculate the score for each request
    current_score = calculate_score(deviations, weights, last_score, variation_threshold_adjusted, volatility_penalty)
    scores.append(current_score)
    last_score = current_score  # Update last score for the next iteration

# Output the scores for review
print(scores)
